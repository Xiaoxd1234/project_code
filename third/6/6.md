任务6 - 多层级图书馆的导航 [12分]
背景
大学通常运营多个图书馆分馆，以服务不同的学院和学科（如IT、药学、艺术）。虽然这提升了可访问性，但也带来了诸如分馆间书籍重复、跨馆请求管理以及确保一致搜索结果等挑战。为解决这些问题，图书馆采用集成管理系统，拥有统一的目录和检索层。

在本次作业中，书籍收藏数据位于 data 文件夹，并以层级结构组织。每个顶层文件夹对应一个图书馆分馆。分馆内，书籍按学科和类别进一步分组。最底层，每个类别以CSV文件（如 machinelearning.csv）表示，包含书籍记录及属性，如 book_id、title、author、year 和 keywords。

例如，来看 PharmacyLibrary（药学图书馆）在 data/PharmacyLibrary 下的结构：
PharmacyLibrary
--Biology
----bioinformatics
------machinelearning.csv
------mathematics.csv
--education.csv

你的任务
你可以在解决方案中定义递归辅助函数。主函数本身不必递归，只要实现中某处用到递归即可。
在任务6中，可假设所有CSV文件数据均有效。

第1部分
使用递归方法，实现函数 read_book_collection(data_path: str) -> dict：读取 data_path 下的图书馆书籍收藏，并返回一个嵌套字典结构，表示不同分馆的层级书籍结构。分馆、学院和部门用字典表示，类别作为键。层级结构需与文件夹结构一致，每条书籍记录需包含 book_id、type、copies、title、author、year 和 keywords。

一本书可能有多个作者，以 & 分隔。
关键词以 : 分隔（同前几任务）。

示例 - 药学图书馆（PharmacyLibrary）书籍分布的层级结构结果：
>>> books_dict = read_book_collection('data/PharmacyLibrary')
>>> books_dict
{'biology': 
   {'bioinformatics': 
       {'machinelearning': [
           {'book_id': 'P0003', 'type': 'physical', 'copies': 1, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming']}, 
           {'book_id': 'P0001', 'type': 'physical', 'copies': 1, 'title': 'Introduction to Python Programming', 'author': ['S Gowrishankar'], 'year': 2019, 'keywords': ['python', 'programming']}
         ], 
        'mathematics': [
           {'book_id': 'P0025', 'type': 'physical', 'copies': 3, 'title': 'Introduction to mathematical statistics', 'author': ["Hogg Robert V", "Craig Allen T"], 'year': 2013, 'keywords': ['statistics', 'mathematical statistics']}
         ]
        }
    },
   'education': [
       {'book_id': 'P0020', 'type': 'physical', 'copies': 1, 'title': 'Research methods', 'author': ['McBurney Donald'], 'year': 2010, 'keywords': ['Research', 'Research methods']},
       {'book_id': 'P0009', 'type': 'physical', 'copies': 1, 'title': 'Bad Science: A hilarious and informative Sunday Times bestseller on bad science in healthcare', 'author': ['Ben Goldacre'], 'year': 2008, 'keywords': ['science', 'statistics', 'healthcare']}
    ]
}

第2部分
图书管理员希望统计整个图书馆系统中每个类别的书籍数量。
你的任务是使用递归方法实现函数 count_books_by_category(data: dict, book_cat: str) -> int

输入：
data：书籍收藏的层级字典（如第1部分构建的）。
book_cat：类别名称（如 "machinelearning"、"deeplearning"、"social_science"）。

输出：
返回属于指定类别的书籍总数，无论分馆或部门位置。

示例
>>>count_books_by_categories(data,'machinelearning')
4
>>>count_books_by_categories(data,'deeplearning')
3
>>>count_books_by_categories(data,'social_science')
4 
>>>count_books_by_categories(data,'education')
6

第3部分
图书管理员希望检索某位作者撰写的所有书籍。
你的任务是使用递归方法实现函数 find_books_by_author(data: dict, author: str) -> list

输入：
data：书籍收藏的层级字典（如第1部分构建的）。
author：要搜索的作者姓名。

输出：
返回由该作者撰写的所有书籍字典列表。每个书籍字典需额外包含 category 字段，记录该书所在类别的完整路径。

task6 例子1
print(find_books_by_author(data, 'Eric Matthes'))
[{'book_id': 'P0003', 'type': 'physical', 'copies': 2, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/computerscience'}, 
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/economics/economics'}, 
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/MathesonLibrary/education'}, 
{'book_id': 'P0003', 'type': 'physical', 'copies': 1, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/PharmacyLibrary/biology/bioinformatics/machinelearning'}]

第4部分
图书管理员希望增强搜索系统，使用户不仅能通过精确关键词匹配，还能通过关键词相似度（不区分大小写）查找书籍。为此，我们将使用 Jaccard 相似度来衡量两个文本中单词的重叠程度。

Jaccard 相似度分数通过将共有元素（交集）的数量除以两个集合所有唯一元素（并集）的数量来计算。

例如，用户搜索与 python programming 相关的书籍，我们有一本书名为 Introduction to Python Programming。我们希望用 Jaccard 相似度分数衡量搜索词与书名的相似度。

关键词列表为 ["python", "programming"]
书名中的唯一单词为 ["introduction", "to", "python", "programming"]
关键词与书名的交集为 ["python", "programming"]（长度为2）
并集为 ["introduction", "to", "python", "programming"]（长度为4）
因此，Jaccard 相似度分数为 2 / 4 = 0.5

扩展
Jaccard 指数（可参考此链接）用于衡量有限非空样本集合之间的相似度，定义为交集大小除以并集大小。假设有非空集合A和B，Jaccard指数计算公式如下：
J(A,B) = |A∩B| / |A∪B| = |A∩B| / (|A| + |B| - |A∩B|)
其中，0≤J(A,B)≤1
J(A,B)=0 表示A和B毫无相似性。
J(A,B)=1 表示A与B完全相同。

你的任务是使用递归方法实现函数 search_by_keywords(data: dict, keywords: list, similarity_threshold: float) -> list

输入：
data：书籍收藏的层级字典（如第1部分构建的）。
keywords：搜索关键词列表。
similarity_threshold：书籍被认为相关的最低相似度分数。

输出：
返回最相关书籍的列表，每本书以字典表示。每个书籍字典需额外包含 category 字段（记录该书所在类别的完整路径）和 similarity score 字段。

结果需先按相似度分数降序排序，再按年份降序排序。
task6 最后一个部分例子

示例1：
>>>search_by_keywords(books_dict,['python', 'programming'], 0.25))
[{'book_id': 'P0001', 'type': 'physical', 'copies': 1, 'title': 'Introduction to Python Programming', 'author': ['S Gowrishankar'], 'year': 2019, 'keywords': ['python', 'programming'], 'category': '/PharmacyLibrary/biology/bioinformatics/machinelearning', 'score': 0.5}, 
{'book_id': 'P0003', 'type': 'physical', 'copies': 2, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/computerscience', 'score': 0.25},
{'book_id': 'P0003', 'type': 'physical', 'copies': 1, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/PharmacyLibrary/biology/bioinformatics/machinelearning', 'score': 0.25},
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/economics/economics', 'score': 0.25},
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/MathesonLibrary/education', 'score': 0.25}]
这个是task6最后一个part的例子Backgrounds
Universities often operate multiple library branches to serve different faculties and disciplines (e.g., IT, Pharmacy, Arts). While this improves accessibility, it also creates challenges such as duplicated books across branches, managing cross-branch requests, and ensuring consistent search results. To address these issues, libraries use integrated management systems with unified catalogues and discovery layers.

In this assignment, the book collection is provided in the data folder, organised in a hierarchical structure. Each top-level folder corresponds to a library branch. Within each branch, books are further grouped by subjects and categories. At the lowest level, each category is represented as a CSV file (e.g., machinelearning.csv) containing book records with attributes such as book_id, title, author, year, and keywords .

For example, let's take a look at the Pharmacy Library in data/PharmacyLibrary. The library can have the following structure:

PharmacyLibrary
--Biology
----bioinformatics
------machinelearning.csv
------mathematics.csv
--education.csv
Your Tasks
You may define a recursive helper function inside your solution. The provided function itself does not need to be recursive, as long as recursion is used somewhere in your implementation.

In Task 6, you can assume all CSV files contain valid data.

Part 1
Using recursive approach, implement a function read_book_collection(data_path: str) -> dict: to read the library book collection at data_path and returns a nested dictionary structure representing a hierarchical structure of books at different library branches, where library branches, faculties, and departments are represented as dictionaries, and categories are listed as keys. The hierarchy should mirror the folder structure and each book record must include attributes such as book_id, type, copies, title, author, year, and keywords.

A book may have multiple authors, separated by &.

Keywords are separated by : (as in previous tasks).

Example - a result hierarchical structure of book distributions in Pharmacy Library (PharmacyLibrary)

>>> books_dict = read_book_collection('data/PharmacyLibrary')
>>> books_dict
{'biology': 
   {'bioinformatics': 
       {'machinelearning': [
           {'book_id': 'P0003', 'type': 'physical', 'copies': 1, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming']}, 
           {'book_id': 'P0001', 'type': 'physical', 'copies': 1, 'title': 'Introduction to Python Programming', 'author': ['S Gowrishankar'], 'year': 2019, 'keywords': ['python', 'programming']}
         ], 
        'mathematics': [
           {'book_id': 'P0025', 'type': 'physical', 'copies': 3, 'title': 'Introduction to mathematical statistics', 'author': ["Hogg Robert V", "Craig Allen T"], 'year': 2013, 'keywords': ['statistics', 'mathematical statistics']}
         ]
        }
    },
   'education': [
       {'book_id': 'P0020', 'type': 'physical', 'copies': 1, 'title': 'Research methods', 'author': ['McBurney Donald'], 'year': 2010, 'keywords': ['Research', 'Research methods']},
       {'book_id': 'P0009', 'type': 'physical', 'copies': 1, 'title': 'Bad Science: A hilarious and informative Sunday Times bestseller on bad science in healthcare', 'author': ['Ben Goldacre'], 'year': 2008, 'keywords': ['science', 'statistics', 'healthcare']}
    ]
}

Part 2
The librarian wants to generate statistics on the number of books available in each category across the library system.

Your task is to use a recursive approach to implement function  count_books_by_category(data: dict, book_cat: str) -> int 

Input:

data: the hierarchical dictionary of book collections (as constructed in Part 1).

book_cat: the name of a category (e.g., "machinelearning", "deeplearning", "social_science").

Output

Returns the total number of books that belong to the specified category, regardless of which branch or department they are located in.

Examples

>>>count_books_by_categories(data,'machinelearning')
4
>>>count_books_by_categories(data,'deeplearning')
3
>>>count_books_by_categories(data,'social_science')
4 
>>>count_books_by_categories(data,'education')
6

Part 3
The librarian would like to retrieve all books written by a specific author.

Your task is to use a recursive approach to implement the function find_books_by_author(data: dict, author: str) -> list

Input:

data:  the hierarchical dictionary of book collections (as constructed in Part 1).

author: the name of the author to search for.

Output:

A list of book dictionaries, where each dictionary represents a book written by the given author.

Each returned book dictionary must also include an additional field, category, which records the full path of the category in which the book is located. task6 要求



print(find_books_by_author(data, 'Eric Matthes'))
[{'book_id': 'P0003', 'type': 'physical', 'copies': 2, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/computerscience'}, 
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/economics/economics'}, 
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/MathesonLibrary/education'}, 
{'book_id': 'P0003', 'type': 'physical', 'copies': 1, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/PharmacyLibrary/biology/bioinformatics/machinelearning'}] task6 例子1




Part 4
The librarian would like to enhance the search system so that users can find books not only by exact keyword matches but also by similarity of keywords (case insensitive). To achieve this, we will use the Jaccard similarity to measure the overlap between words in two texts. 

Jaccard similarity score is calculated by dividing the number of shared elements (intersection) by the total number of unique elements in both sets (union). 

Let's say a user searches for books related to python programming, and we have a book titled Introduction to Python Programming. We want to measure how similar the search query is to the book's title using the Jaccard similarity score.

The keyword list is ["python", "programming"]

The unique words in the book title are ["introduction", "to", "python", "programming"]

The intersection between keywords and the book title is ["python", "programming"] (length of 2)

The union is ["introduction", "to", "python", "programming"] (length of 4)

Hence, the Jaccard similarity score is 2 / 4 = 0.5


Expand
 Jaccard  index  (for your interest, please refer to this link) measures similarity between finite non-empty sample sets and is defined as the size of the intersection divided by the size of the union of the sample sets.  Suppose we have non-empty A and B sets, jaccard index is calculated using the formula:

J
(
A
,
B
)
 
=
 
∣
A
∩
B
∣
∣
A
∪
B
=
∣
A
∩
B
∣
∣
A
∣
+
∣
B
∣
−
∣
A
∩
B
∣
J(A,B) =  
∣A∪B
∣A∩B∣
​
 = 
∣A∣+∣B∣−∣A∩B∣
∣A∩B∣
​
 

where, 

0
≤
J
(
A
,
B
)
≤
1
0≤J(A,B)≤1

 J(A,B) = 0  means there is no similarity between A and B.

J(A,B) = 1 means A is identical to B. 

Your task is use a recursive approach to implement a function search_by_keywords(data: dict, keywords: list, similarity_threshold: float) -> list

Input:

data:  the hierarchical dictionary of book collections (as constructed in Part 1).

keywords: a list of search keywords.

similarity_threshold: the minimum similarity score a book must have to be considered relevant.

Output:

A list of the most relevant books, each represented as a dictionary. Each returned book dictionary must also include additional fields, category, which records the full path of the category in which the book is located, and the similarity score .

The results should be sorted first by similarity score (descending) and then by year (descending). task 6 接下来




Example 1:

>>>search_by_keywords(books_dict,['python', 'programming'], 0.25))
[{'book_id': 'P0001', 'type': 'physical', 'copies': 1, 'title': 'Introduction to Python Programming', 'author': ['S Gowrishankar'], 'year': 2019, 'keywords': ['python', 'programming'], 'category': '/PharmacyLibrary/biology/bioinformatics/machinelearning', 'score': 0.5}, 
{'book_id': 'P0003', 'type': 'physical', 'copies': 2, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/computerscience', 'score': 0.25},
{'book_id': 'P0003', 'type': 'physical', 'copies': 1, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2023, 'keywords': ['python', 'programming'], 'category': '/PharmacyLibrary/biology/bioinformatics/machinelearning', 'score': 0.25},
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/LawLibrary/economics/economics', 'score': 0.25},
{'book_id': 'E0001', 'type': 'online', 'copies': 0, 'title': 'Python Crash Course', 'author': ['Eric Matthes'], 'year': 2015, 'keywords': ['python', 'programming'], 'category': '/MathesonLibrary/education', 'score': 0.25}] 这个是task6最后一个part的例子