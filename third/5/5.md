ä»»åŠ¡5 - ä½ æ˜¯è‡ªåŠ¨è¯„åˆ†å‘˜ [8åˆ†]
èƒŒæ™¯
åœ¨æˆåŠŸä¿®å¤å›¾ä¹¦é¦†ç³»ç»Ÿä¸­çš„é€»è¾‘é”™è¯¯å¹¶å¤„ç†æŸåçš„CSVæ•°æ®åï¼Œä½ ç°åœ¨è¢«åˆ†é…å¼€å‘ä»£ç åº“çš„è‡ªåŠ¨åŒ–æµ‹è¯•ã€‚åœ¨åƒå›¾ä¹¦é¦†æ•°æ®åº“è¿™æ ·çš„å¤§å‹ç³»ç»Ÿä¸­ï¼ŒåŠæ—©å‘ç°é”™è¯¯è‡³å…³é‡è¦ã€‚è‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•ä¸ºåå¤éªŒè¯ç³»ç»Ÿåœ¨æ­£å¸¸å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸ºæ˜¯å¦ç¬¦åˆé¢„æœŸæä¾›äº†å¯é çš„æ–¹æ³•ã€‚
ä½ çš„ä»»åŠ¡æ˜¯ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œä»¥ç¡®ä¿ï¼š
æ‰€æœ‰åŠŸèƒ½åœ¨æœ‰æ•ˆè¾“å…¥ä¸‹éƒ½èƒ½æ­£å¸¸å·¥ä½œã€‚
ç³»ç»Ÿåœ¨æ— æ•ˆè¾“å…¥ä¸‹èƒ½ä¼˜é›…åœ°å¤±è´¥ã€‚
è¿™äº›æµ‹è¯•å°†ä¸»è¦é’ˆå¯¹ä½ åœ¨ user.py å’Œ book.py ä¸­å®ç°çš„ç±»ã€‚
åœ¨å®Œæˆç¬¬4ä»»åŠ¡çš„ä»£ç åï¼Œä½ åº”è¯¥èƒ½å¤Ÿç‚¹å‡»è¿è¡Œæµ‹è¯•å¹¶çœ‹åˆ°å¦‚ä¸‹å†…å®¹ï¼š

ä»»åŠ¡è¯´æ˜
ä½ çš„ç›®æ ‡æ˜¯ç¼–å†™ä¸€å¥—å•å…ƒæµ‹è¯•ï¼Œè¦†ç›–å„ç§æ­£å¸¸å’Œè¾¹ç•Œæƒ…å†µï¼Œä»¥æ£€æŸ¥ä½ åœ¨ä¸Šä¸€ä»»åŠ¡ä¸­çš„å·¥ä½œã€‚
ä½ å¿…é¡»ï¼š
ä¸º user.py å’Œ book.py ä¸­æ‰€æœ‰ç±»çš„æ¯ä¸ªå…¬å…±æ–¹æ³•ç¼–å†™æµ‹è¯•ç”¨ä¾‹ï¼Œåˆ†åˆ«æ”¾åœ¨ test_user.py å’Œ test_book.py æ–‡ä»¶ä¸­ã€‚
æµ‹è¯•æ­£ç¡®å’Œé”™è¯¯çš„è¾“å…¥ã€‚
ä½¿ç”¨ assertEqualã€assertRaises ä»¥åŠï¼ˆå¯é€‰ï¼‰å…¶ä»–æ–­è¨€å¦‚ assertIsInstanceã€assertGreaterEqual ç­‰ã€‚
ä½¿ç”¨ unittest ç­‰æµ‹è¯•æ¡†æ¶ç»„ç»‡ä½ çš„æµ‹è¯•ã€‚

è¦æ±‚
âœ… æ­£é¢æ¡ˆä¾‹ç¤ºä¾‹ï¼š
æ£€æŸ¥æ‰€æœ‰è¾“å…¥å‡æœ‰æ•ˆæ—¶çš„æƒ…å†µã€‚
æ£€æŸ¥å€Ÿé˜…å’Œå½’è¿˜æœ‰æ•ˆä¹¦ç±ã€‚
âŒ è´Ÿé¢æ¡ˆä¾‹ï¼šæ£€æŸ¥å€Ÿé˜…æ—¶è¾“å…¥ç±»å‹å’Œå€¼æ— æ•ˆçš„æƒ…å†µã€‚
ğŸ§ª æµ‹è¯•ç»“æ„ï¼š
å°†ç›¸å…³æµ‹è¯•åˆ†ç»„åˆ°æµ‹è¯•æ–¹æ³•ä¸­ã€‚
æ³¨æ„ï¼šä½ åº”è¯¥ä½¿ç”¨åœ¨ç¬¬4ä»»åŠ¡ä¸­å®ç°çš„ custom_errors.py ä¸­çš„é”™è¯¯ã€‚
è¿™ä¸ªæ˜¯task5Background
After successfully fixing logic bugs in the library system and handling corrupted CSV data, you are now assigned to develop automated tests for the codebase. In large systems like the library database, catching bugs early is crucial. Automated unit tests provide a reliable way to repeatedly verify that the system behaves as expected under both normal and faulty conditions.
Your task is to write unit tests that ensure:
All features work correctly with valid input.
The system fails gracefully when given invalid input.
These tests will focus on the classes you implemented in user.py and book.py.
After putting your code from task 4 in. You should be able to click the run tests and see the following:

Description
Your goal is to write a suite of unit tests that cover a wide range of normal and edge-case behaviours which will check your work from the previous task.
You must:
Write test cases for each public method of all classes written in user.py and book.py to test_user.py and test_book.py.
Test for both correct and incorrect inputs.
Use assertEqual, assertRaises, and (optionally) other assertions like assertIsInstance, assertGreaterEqual, etc.
Organise your tests using a testing framework such as unittest.
Requirements
âœ…Some Examples of Positive Cases:
Check when all the inputs are valid.
Check borrowing and returning valid books.
âŒ Negative Cases: Check borrowing with invalid types & values.
ğŸ§ª Test Structure:
Group related tests into test methods.
Note: You should be using the errors from custom_errors.py that you implemented in Task 4.
è¿™ä¸ªæ˜¯task5