[Set 4] Task 9: Game Menu and Control Flow (26 marks)
Overview
In this final task, you will design and implement a combat system for your adventure game. Each turn, the player will encounter a random enemy and choose how to respond: attack, defend, or run. You will track damage, victory rewards, player healing, and defeat conditions all integrated into a reusable function that updates the player state.

This is your most advanced task and combines everything: state tracking, function design, combat flow control, user decision-making, and stat updates.

This is the most complex task of the set there are two functions required combat_encounter & get_menu_choice however, it's strongly recommended to break down the logic of the combat_encounter into multiple smaller functions.

Task Description
Define a functions combat_encounter(player_state, enemy_id) -> dict and get_menu_choice(prompt: str, options: list[str]) -> str .

Please refer to the sample outputs of the program. Be sure to match precisely.

Implement the updated player state

Player State Requirements
Your player_state dictionary must include these fields there is no specific order required:

{
  "name": str,
  "health": int,
  "max_health": int,
  "inventory": list,
  "attack": int,
  "location": str,
  "experience": int,
  "gold": int,
  "enemies_defeated": int
}

Note: This dictionary as well as the enemies dictionary will be replaced during testing. Your logic must work with any valid structure containing the above fields.

Enemy Configuration
Each enemy has:

id identity code for each enemy, this is unique. 

name some enemies may share a name.

health

attack (max damage dealt per turn)

experience (earned on victory)

gold (earned on victory)

Although the enemy has experience and gold attributes these are fixed. So should the enemy defeat the player they will not gain any of these resources.

You must store your enemies in a dictionary named enemies . This will be replaced in testing.


Requirements please read carefully:
combat_encounter(state: dict, enemy_id: int) -> None

Paramaters:

state: a dictionary representing the current player state.

enemy_id: an integer that maps to an enemy in the enemies dictionary

You can assume all inputs to this function will be valid, i.e not missing attributes in the dictionary or an enemy_id that doesn't have a enemy associated.

Functionality:

A encounter is only ended if one of the three outcomes occur:

Player is able to run away

Player defeats the enemy

Player is defeated by the enemy

If none of the above outcomes are reached combat continues

If the player has any of the following in inventory: "Rusty Sword", "Iron Dagger", "Magic Scroll" add +2 to attack

The message [Weapon name] boosts your attack! should be printed your encounter should this condition be met. An example of this is given.

You can hold multiple items in your inventory including duplicates.

Each instance of the above mentioned items should display the [Weapon name] boosts your attack! message and increase the player's attack by 2.

Actions:

[A]ttack: deal damage to the enemy equal to the player's attack

The enemy (provided their hp is above 0) will then attack after the player (See video)

[D]efend: halve incoming damage (minimum 1 will be dealt) from the enemy.

Halving is to be done by using integer division.

[R]un: If it's the first action chosen by escape will always be successful otherwise it will always fail and the enemy will attack.

After victory:

Gain XP, gold, and count the enemy defeated

Print the victory message  \n[Player name] defeated the [Enemy name]!

and Gained [Xp amount] XP and [Gold amount gold.

Heal 5, but cap at max_health updating the player's state

After defeat:

Print the defeat message  \n [Player name] was defeated by the [Enemy name]...

No XP/gold is gained.

State management:

After each attack the attacker (player or enemy) should have their state updated

You don't need to consider multiple battles, as such please don't add in additional logic that isn't described in this task. Such as reseting the monster state.

The function should return the player state after the battle.

If the player's health is 50% or less (still greater than zero) their total damage (damage including any boosts) dealt is doubled. However, their attack in their stats does not change. 

get_menu_choice(prompt: str, options: list[str]) -> str

Paramaters:

prompt: message that should be printed

options: a list of case insensitive valid inputs

the selected answer

You will repeatedly re prompt the user until they provide an input that is within the options list. Options are all case insensitive so if the options list was ["A"] then "a" or "A" would be accepted. 

Task Demonstration
If you're unable to load the video try downloading it directly via:

File
Task9Demo.mov

In this video I demonstrate various different scenarios including invalid input and fighting different monsters that have a variety of different stat values. For this task you don't have to be precise with your outputs like previous tasks but your tutor will run your program so it needs to have appropriate messaging you shouldn't look to copy what's in the video exactly just add print statements when something happens in the game logic (eg player is defeated ect).

How To Read The Provided Tests:
At the end of the test name you will see what inputs are used in that specific test for example (4 a a) means:

4
a
a
Skeleton was selected then it was attacked twice.  Ensure you are returning your player_state in combat_encounter not printing instead.

Submission Instructions
Save your file as task9.py

Run several times to test victory, flee, and defeat scenarios







          
【第4组】任务9：游戏菜单与控制流（26分）

概述
在本最终任务中，你将为冒险游戏设计并实现一个战斗系统。每回合，玩家会遇到一个随机敌人，并选择如何应对：攻击、防御或逃跑。你需要跟踪伤害、胜利奖励、玩家治疗和失败条件，并将这些逻辑集成到一个可复用的函数中，实时更新玩家状态。

这是本组最复杂的任务，综合了所有内容：状态跟踪、函数设计、战斗流程控制、用户决策和属性更新。

本任务需要实现两个函数：combat_encounter 和 get_menu_choice。强烈建议将combat_encounter的逻辑拆分为多个小函数。

任务描述
定义函数 combat_encounter(player_state, enemy_id) -> dict 和 get_menu_choice(prompt: str, options: list[str]) -> str。

请参考程序的示例输出，确保精确匹配。

实现更新后的玩家状态

玩家状态要求
你的player_state字典必须包含以下字段，顺序不限：
{
  "name": str,
  "health": int,
  "max_health": int,
  "inventory": list,
  "attack": int,
  "location": str,
  "experience": int,
  "gold": int,
  "enemies_defeated": int
}

注意：该字典以及enemies字典将在测试时被替换。你的逻辑必须适用于任何包含上述字段的有效结构。

敌人配置
每个敌人有：
id：每个敌人的唯一标识码
name：有些敌人可能同名
health：生命值
attack：每回合最大伤害
experience：胜利时获得的经验
gold：胜利时获得的金币

虽然敌人有经验和金币属性，但这些是固定值。如果敌人击败玩家，他们不会获得这些资源。

你必须将敌人存储在名为enemies的字典中。该字典将在测试时被替换。

详细要求：
combat_encounter(state: dict, enemy_id: int) -> None
参数：
state：表示当前玩家状态的字典
enemy_id：整数，对应enemies字典中的一个敌人
你可以假设所有输入都是有效的，即不会缺少属性或出现无效enemy_id。

功能：
一次遭遇战只有以下三种结果之一时才结束：
- 玩家成功逃跑
- 玩家击败敌人
- 玩家被敌人击败
如果未达到上述结果，战斗继续。

如果玩家物品栏中有以下任意物品：“Rusty Sword”、“Iron Dagger”、“Magic Scroll”，攻击力+2。
每有一个上述物品，需打印[Weapon name] boosts your attack!，并增加2点攻击力。
物品栏可有多个物品，包括重复。
每有一个上述物品都需显示一次提示并增加攻击力。

操作：
[A]ttack：对敌人造成等于玩家攻击力的伤害
敌人（若生命值大于0）会在玩家攻击后反击
[D]efend：本回合敌人伤害减半（最少造成1点伤害），用整数除法
[R]un：如果第一次选择逃跑必定成功，否则必定失败且敌人攻击

胜利后：
获得经验、金币，并计数击败的敌人
打印胜利信息：[玩家名] defeated the [敌人名]!
以及获得的经验和金币信息
玩家恢复5点生命值，但不超过最大生命值

失败后：
打印失败信息：[玩家名] was defeated by the [敌人名]...
不获得经验和金币

状态管理：
每次攻击后，攻击者（玩家或敌人）需更新其状态
无需考虑多场战斗，不要添加未描述的额外逻辑（如重置怪物状态）
函数应返回战斗后的玩家状态

如果玩家生命值≤最大值的50%且>0，则本回合总伤害（包括加成）翻倍，但玩家属性中的攻击力不变。

get_menu_choice(prompt: str, options: list[str]) -> str
参数：
prompt：要打印的提示信息
options：大小写不敏感的有效输入列表
返回用户选择的答案

你需要不断提示用户，直到输入在options列表中（大小写不敏感）。例如，options为["A"]时，输入"a"或"A"都可接受。

任务演示
如无法加载视频，可直接下载：Task9Demo.mov

视频演示了各种场景，包括无效输入和与不同属性怪物的战斗。你无需像前面任务那样精确输出，但需要在游戏逻辑发生时（如玩家被击败等）添加适当的提示信息。

如何阅读测试用例：
测试名末尾会显示输入，例如（4 a a）表示：
4
a
a
即选择Skeleton并攻击两次。确保combat_encounter返回player_state而不是直接打印。

提交说明
保存文件为task9.py
多次运行以测试胜利、逃跑和失败场景。

        